---
description: These are the most common malware APIs & techniques used.
cover: https://website.cdn.group-ib.com/wp-content/uploads/blog-2.png
coverY: 425
---

# Common Techniques & APIs

## <mark style="color:red;">Malware APIs</mark>

### <mark style="color:yellow;">Networking</mark>

| Raw Sockets   | WinAPI Sockets |
| ------------- | -------------- |
| socket()      | WSAStratup()   |
| bind()        | bind()         |
| listen()      | listen()       |
| accept()      | accept()       |
| connect()     | connect()      |
| read()/recv() | recv()         |
| write()       | send()         |
| shutdown()    | WSACleanup()   |

### <mark style="color:yellow;">Persistence</mark>

| Registry         | File          | Service                      |
| ---------------- | ------------- | ---------------------------- |
| RegCreateKeyEx() | GetTempPath() | OpenSCManager                |
| RegOpenKeyEx()   | CopyFile()    | CreateService()              |
| RegSetValueEx()  | CreateFile()  | StartServiceCtrlDispatcher() |
| RegDeleteKeyEx() | WriteFile()   |                              |
| RegGetValue()    | ReadFile()    |                              |

### <mark style="color:yellow;">Encryption</mark>

| Name                  |
| --------------------- |
| WinCrypt              |
| CryptAcquireContext() |
| CryptGenKey()         |
| CryptDeriveKey()      |
| CryptDecrypt()        |
| CryptReleaseContext() |

### <mark style="color:yellow;">Anti-Analysis/VM</mark>

| Function Name                                             | Assembly Instructions |
| --------------------------------------------------------- | --------------------- |
| IsDebuggerPresent()                                       | CPUID()               |
| GetSystemInfo()                                           | IN()                  |
| GlobalMemoryStatusEx()                                    |                       |
| GetVersion()                                              |                       |
| CreateToolhelp32Snapshot \[Check if a process is running] |                       |
| CreateFileW/A \[Check if a file exist]                    |                       |

### <mark style="color:yellow;">Stealth</mark>

| Name                     |                                                                            |
| ------------------------ | -------------------------------------------------------------------------- |
| VirtualAlloc             | Alloc memory (packers)                                                     |
| VirtualProtect           | Change memory permission (packer giving execution permission to a section) |
| ReadProcessMemory        | Injection into external processes                                          |
| WriteProcessMemoryA/W    | Injection into external processes                                          |
| NtWriteVirtualMemory     |                                                                            |
| CreateRemoteThread       | DLL/Process injection...                                                   |
| NtUnmapViewOfSection     |                                                                            |
| QueueUserAPC             |                                                                            |
| CreateProcessInternalA/W |                                                                            |

### <mark style="color:yellow;">Execution</mark>

| Function Name    |
| ---------------- |
| CreateProcessA/W |
| ShellExecute     |
| WinExec          |
| ResumeThread     |
| NtResumeThread   |

### <mark style="color:yellow;">Miscellaneous</mark>

* **GetAsyncKeyState()** -- Key logging.
* **SetWindowsHookEx** -- Key logging.
* **GetForeGroundWindow** -- Get running window name (or the website from a browser).
* **LoadLibrary()** -- Import library.
* **GetProcAddress()** -- Import library.
* **CreateToolhelp32Snapshot()** -- List running processes.
* **GetDC()** -- Screenshot.
* **BitBlt()** -- Screenshot.
* **InternetOpen(), InternetOpenUrl(), InternetReadFile(), InternetWriteFile()** -- Access the Internet.
* **FindResource(), LoadResource(), LockResource()** -- Access resources of the executable.

## <mark style="color:red;">Malware Techniques</mark>

### <mark style="color:yellow;">DLL Injection</mark>

#### <mark style="color:purple;">Execute an arbitrary DLL inside another process:</mark>

1. Locate the process to inject the malicious DLL: CreateToolhelp32Snapshot, Process32First, Process32Next.
2. Open the process: GetModuleHandle, GetProcAddress, OpenProcess.
3. Write the path to the DLL inside the process: VirtualAllocEx, WriteProcessMemory.
4. Create a thread in the process that will load the malicious DLL: CreateRemoteThread, LoadLibrary.

#### <mark style="color:purple;">Other functions to use:</mark>&#x20;

* NTCreateThreadEx
* RtlCreateUserThread

### <mark style="color:yellow;">Reflective DLL Injection</mark>

#### <mark style="color:purple;">Load a malicious DLL without calling normal Windows API calls:</mark>

\
The DLL is mapped inside a process, it will resolve the import addresses, fix the relocations and call the DllMain function.

### <mark style="color:yellow;">Thread Hijacking</mark>

#### <mark style="color:purple;">Find a thread from a process and make it load a malicious DLL:</mark>

1. Find a target thread: CreateToolhelp32Snapshot, Thread32First, Thread32Next.
2. Open the thread: OpenThread.
3. Suspend the thread: SuspendThread.
4. Write the path to the malicious DLL inside the victim process: VirtualAllocEx, WriteProcessMemory.
5. Resume the thread loading the library: ResumeThread.

### <mark style="color:yellow;">PE Injection</mark>

#### <mark style="color:purple;">Portable Execution Injection:</mark>&#x20;

The executable will be written in the memory of the victim process and it will be executed from there.

### <mark style="color:yellow;">Process Hollowing</mark>

#### <mark style="color:purple;">The malware will unmap the legitimate code from memory of the process and load a malicious binary:</mark>

1. Create a new process: CreateProcess.
2. Unmap the memory: ZwUnmapViewOfSection, NtUnmapViewOfSection.
3. Write the malicious binary in the process memory: VirtualAllocEx, WriteProcessMemory.
4. Set the entrypoint and execute: SetThreadContext, ResumeThread.

### <mark style="color:yellow;">Hooking</mark>

* **The SSDT (System Service Descriptor Table):** Points to kernel functions (ntoskrnl.exe) or GUI driver (win32k.sys) so user processes can call these functions. A rootkit may modify these pointer to addresses that he controls.
* **IRP (I/O Request Packets):** Transmit pieces of data from one component to another. Almost everything in the kernel uses IRPs and each device object has its own function table that can be hooked using DKOM (Direct Kernel Object Manipulation).
* **The IAT (Import Address Table):** Is useful to resolve dependencies. It's possible to hook this table in order to hijack the code that will be called.
* **EAT (Export Address Table) Hooks:** This hooks can be done from **userland**. The goal is to hook exported functions by DLLs.
* **Inline Hooks**: This type are difficult to achieve. This involve modifying the code of the functions itself. Maybe by putting a jump at the beginning of this.
